# 第五讲 动态规划

动态规划问题没有算法模板

状态转移方程

> 动态规划算法是一种用于解决优化问题的算法思想。它通过将问题分解为子问题，并以递推的方式求解子问题的最优解，从而得到原问题的最优解。
>
> 动态规划算法通常适用于满足最优子结构和重叠子问题性质的问题。最优子结构意味着问题的最优解可以由其子问题的最优解构成，而重叠子问题则指在求解过程中会反复遇到相同的子问题。
>
> 动态规划算法的基本步骤如下：
>
> 1. 定义状态：确定问题的状态表示，即找出需要存储的信息，以便进行后续的计算。
> 2. 确定状态转移方程：建立问题的状态之间的转移关系，即根据子问题的最优解推导出原问题的最优解。
> 3. 初始条件：确定问题的边界条件，即最简单的情况下的解。
> 4. 自底向上求解：按照自底向上的顺序，通过状态转移方程和已知的初始条件来计算并填充状态表格（或者直接更新状态数组）。
> 5. 提取结果：根据问题的要求，从最终的状态表格（或者状态数组）中提取出所需的结果。
>
> 动态规划算法在求解问题时，利用了子问题的重叠性质，避免了重复计算，从而显著提高了效率。它常常用于解决诸如最长公共子序列、背包问题、最短路径问题等优化问题。



## 1. 背包问题

并不一定要将背包完全装满

### 01背包问题（每件物品最多只用一次）

N个物品，和一个容量是V的背包

每个物品都有vi和价值wi，每个物品只能用一次

使背包中的物品价值最大



DP问题从两个角度来考虑

从集合的角度：

f(i, j) 表示的是集合中所有选法的最大值

1. 状态表示：需要几维数组来表示f(i,j)；集合（所有选法，条件（只考虑前i个物品、选出来总体积小于等于j））和属性（最大值、最小值、数量）

2. 状态计算：如何一步步算f(i, j) --集合的划分   f(i, j)如何用更小的集合划分：把f(i, j)分成两大类：不含第i个放到左边 （f(i -1, j）)、包含第i个放到右边去(f(i - 1, j - vi) + wi)
3. f(i, j) = max(f(i -1, j), f(i - 1, j - vi) + wi);

 f(i - 1, j - vi) + wi 是有可能不存在的，wi可能大于最大限制，那么就是空集了

动态规划的网上思维方式结构、状态、最后子结构太抽象了



```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1010;
int n, m;
int v[N], w[N];
int f[N][N];


int main () {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    // 因为f[0][0~m]全局变量本身就是0，就不对他赋值了
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```







### 完全背包问题（每件物品可用无限次）





### 多重背包问题（每个物品个数不一样）





### 多重背包问题2（优化版）





### 分组背包问题（物品有n组，每组里面若干个，每组只能选一个）





#### 对于01背包一维优化的一点理解：

二维转化为一维：
删掉了第一维：在前i个物品中取。
f[j]表示：拿了总体积不超过j的物品，最大总价值。

为何能转化为一维？
二维时的更新方式：f[i][j]=max(f[i - 1][j] ,f[i - 1][j - v[i]] + w[i]);
1.我们发现，对于每次循环的下一组i，只会用到i-1来更新当前值，不会用到i-2及之前值。于是可以在这次更新的时候，将原来的更新掉，反正以后也用不到。
所以对于i的更新，只需用一个数组，直接覆盖就行了。
2.我们发现，对于每次j的更新，只需用到之前i-1时的j或者j-v[i]，不会用到后面的值。
所以为了防止串着改，我们采取从后往前更新的方式，用原来i-1的数组来更新i。
（如果从前往后更新的话，前面的更新过之后，会接着更新后面的值，这样就不能保证是用原来i-1的数组来更新i的了）

如何转化为一维呢？
只用一个数组，每次都覆盖前面的数组。

1.如果当前位置的东西不拿的话，和前一位置的信息（原来i-1数组的这个位置上的值）是相同的，所以不用改变。
2.如果当前位置的东西拿了的话，需要和前一位置的信息（原来i-1数组的这个位置上值）取max。
所以，更新方式就为：f[j]=max(f[j],f[j-v[i]]+w[i]);

整个更新方式就相当于：

每次i++，就从后往前覆盖一遍f数组，看每个位置上的值是否更新。

> 结论：选择n件物品时，容量小于m的值都没意义，f[n][m]只取决于f[n-1][m]和f[n-1][m-v[n]]+w[n]。
> 因为是倒着更新，所以f[m]只和上一次的f[m]和f[m-v[i]]有关。
> 当i==n时，执行完f[m]那行代码可以break掉。
> 在朴素版代码中，当i==n时，可以直接判定f[n][m]然后break，不需要j从0到m的循环。
> 在朴素版的代码中，j不能从v[i]开始，因为如果v[i] > m，f[n][0~m]没有更新。

> 插一句，滚动数组的本质还是减少空间复杂度，好比斐波拉契数列，递推式是f[n] = f[n - 1] + f[n - 2],我们只需要前两个数就可以递推下去数列，通过不断的覆盖，更新，本来需要额外开数组来存储的空间就省了下来，而dp问题是经典的以空间换时间，降低了空间复杂度其实也就是降低了时间复杂度

> 可行性：二维状态转移方程针对第i个物品做规划的时候，所有数据只依赖于第i-1个物品规划的过程，所以可以使用一维滚动数组；
> 逆序更新：因为 j-v[i] 小于等于j，所以如果j从0开始规划，那么在更新“选取物品i的选择方案”时，会用本轮（第i个物品规划）的比较小的物品容量j时被更新过的数据，这个数据反映的是本轮针对第i个物品的规划，不是第i-1个物品的规划，所以与原始算法不等价，采取倒序的方式更新，这样可以保留上一轮i-1的信息。





#### 为什么二进制优化可以

题目的意思是某物品最多有s件，我们需要从所有的物品中选择若干件，使这个背包的价值最大。题目并没有说某物品一定需要选多少件出来，也没有说一共要选多少件出来。只是选择若干件，至于选几件，无所谓，但要保证价值最大。按照优化的策略某物品有s件，我们给其打包分成了好几个大的物品。第一个大物品是包含原来该物品的1件，第二个大物品是包含原来该物品的2件，第三个大物品是包含原来该物品的4件，第四个大物品是包含原来该物品的8件,.....依次类推。此时我们就把所有的物品都重新进行了一个分类。原先每个物品最多s件，我们就把这个件数条件给消去了。取而代之的是，按照一定原先件数组合出来的新若干大物品。我们又已知按照我们划分成大物品进行搭配组合，一定能转化为原先的若干件小物品出来。并且选择某物品的最多件数，是不会超过原先该物品的s件。所以就转化为从下面这些若干件大物品中，选择能使背包容积最大大的情况下，价值最高。这个就是一个01问题。









